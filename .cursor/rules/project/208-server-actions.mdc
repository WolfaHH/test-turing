---
description: EXPLAIN how to create and USE server action with next-safe-action library
globs: *.ts, *.tsx
---
## Context

* Server Actions are a way to execute server-side code (like database mutations) without API endpoints. It's a React abstraction to handle server-side code.
* We use `next-safe-action` to handle authentication, security, and to verify the data we receive.

## Usage

1. Create server action files

We use `server-action-name.action.ts` convention to easily recognize server actions.

```ts
// All server actions must start with "use server" to inform Next.js that this method must be executed on the server
"use server";

import { z } from "zod";
import { orgAction } from "@/lib/actions/safe-actions";
import { prisma } from "@/lib/prisma";

// orgAction is a utility from the library "next-safe-action" that handles middleware to verify the permissions of the user.
// Use `authAction` for non-org-related actions.

const Schema = z.object({
  name: z.string(),
  schema: z.string(),
});

// Server actions must ALWAYS be suffixed with "Action" like "deleteUserAction"
export const demoAction = orgAction
  // We can limit the action to specific roles
  .metadata({
    roles: ["admin", "owner"],
    permissions: { databases: ["create"] },
  })
  // The schema is used to validate the input of the action
  .inputSchema(Schema)
  .action(async ({ parsedInput: input, ctx }) => {
    // We can do async code here
    const database = await prisma.database.create({
      data: {
        name: input.name,
        schema: input.schema,
        organizationId: ctx.org.id,
      },
    });

    return database;
  });
```

2. Use the server action in a client component

In any client component we can use Server Actions like the following example:

```tsx
import { demoAction } from "./server-action-name.action";
import { useMutation } from "@tanstack/react-query";
import { resolveActionResult } from "@/lib/actions/actions-utils";

export const Form = () => {
  // ...

  const mutation = useMutation({
    mutationFn: async (data: FormData) =>
      resolveActionResult(demoAction(data)),
    onError: (error) => toast.error(error.message),
    onSuccess: (result) => {
      toast.success("Demo Action executed!");
    },
  });
```

## Rules

- Always suffix server actions with "Action" like "updateUserAction" or "createSubscriberAction"
- Use `inputSchema` instead of `schema` for validation
- Always include necessary imports (z, prisma, etc.)

## Available actions

* `action`: for general actions without any authentication
* `authAction`: for actions that need to be authenticated
* `orgAction`: for actions that need to be authenticated and relative to organization

## Files

* [safe-actions.ts](mdc:src/lib/actions/safe-actions.ts)



